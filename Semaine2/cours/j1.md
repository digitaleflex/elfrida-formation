# **üöÄ Jour 1 : Programmation Orient√©e Objet (POO) en PHP**  

## **üéØ Objectifs du jour :**  
- Comprendre les concepts fondamentaux de la **POO** et ses avantages pratiques
- Ma√Ætriser la structuration du code avec **classes et objets**
- Explorer en profondeur les concepts avanc√©s : **h√©ritage, polymorphisme, interfaces, traits et classes abstraites**
- Appliquer ces connaissances dans un mini-projet complet : un **gestionnaire de t√¢ches**

---

## **üìå Introduction : Pourquoi utiliser la POO ?**  

Imagine que tu d√©veloppes une application de gestion de t√¢ches en PHP proc√©dural. Tu aurais probablement des fonctions s√©par√©es pour ajouter, modifier et supprimer des t√¢ches. Mais au fil du temps, avec l'ajout de nouvelles fonctionnalit√©s, ton code devient difficile √† maintenir, √† d√©boguer et √† faire √©voluer.

üëâ **La Programmation Orient√©e Objet (POO)** r√©sout ces probl√®mes en permettant de **structurer** et **modulariser** le code en regroupant les donn√©es (propri√©t√©s) et les comportements (m√©thodes) dans des entit√©s appel√©es objets.

### **‚úÖ Avantages de la POO :**  
‚úÖ **Organisation du code** : Regroupement logique des donn√©es et fonctionnalit√©s li√©es
‚úÖ **R√©utilisabilit√©** : Les objets peuvent √™tre instanci√©s plusieurs fois et r√©utilis√©s dans diff√©rents contextes
‚úÖ **Maintenabilit√©** : Modification d'une partie du code sans affecter les autres
‚úÖ **√âvolutivit√©** : Ajout de nouvelles fonctionnalit√©s sans r√©√©crire le code existant
‚úÖ **Collaboration** : Plusieurs d√©veloppeurs peuvent travailler sur diff√©rentes classes simultan√©ment
‚úÖ **S√©curit√©** : Protection des donn√©es gr√¢ce √† l'encapsulation
‚úÖ **Abstraction** : Simplification de la complexit√© en exposant uniquement les interfaces n√©cessaires

---

## **üìå 1. Les Bases de la POO en PHP**  

### **1.1 Classes et Objets**  

Une **classe** est un plan, un mod√®le qui d√©finit la structure et le comportement d'un type d'objet sp√©cifique. Un **objet** est une instance concr√®te de cette classe.

```php
<?php
// D√©finition d'une classe
class Tache {
    // Propri√©t√©s (attributs) de la classe
    public $nom;
    public $description;
    public $statut = '√Ä faire'; // Valeur par d√©faut
    
    // Constructeur : s'ex√©cute automatiquement √† l'instanciation
    public function __construct($nom, $description = '') {
        $this->nom = $nom;
        $this->description = $description;
    }
    
    // M√©thode : une fonction √† l'int√©rieur d'une classe
    public function afficherDetails() {
        return "T√¢che : {$this->nom} | Statut : {$this->statut} | Description : {$this->description}";
    }
    
    // M√©thode pour marquer une t√¢che comme termin√©e
    public function terminer() {
        $this->statut = 'Termin√©e';
        return "La t√¢che \"{$this->nom}\" a √©t√© marqu√©e comme termin√©e.";
    }
}

// Instanciation d'objets (cr√©ation d'instances de la classe)
$tache1 = new Tache("Apprendre PHP", "√âtudier les bases et la POO");
$tache2 = new Tache("Cr√©er un projet");

// Utilisation des objets
echo $tache1->afficherDetails() . "<br>";
echo $tache2->afficherDetails() . "<br>";
echo $tache1->terminer() . "<br>";
echo $tache1->afficherDetails() . "<br>";
?>
```

### **Explication d√©taill√©e :**
1. **D√©finition de classe** : La classe `Tache` est un mod√®le pour cr√©er des objets t√¢ches.
2. **Propri√©t√©s** : `$nom`, `$description` et `$statut` repr√©sentent les donn√©es que chaque t√¢che poss√®de.
3. **Constructeur** : La m√©thode sp√©ciale `__construct()` initialise les propri√©t√©s lorsqu'un objet est cr√©√©.
4. **M√©thodes** : `afficherDetails()` et `terminer()` d√©finissent les comportements que les objets t√¢ches peuvent effectuer.
5. **Cr√©ation d'objets** : `new Tache()` cr√©e une nouvelle instance de la classe.
6. **Utilisation** : On acc√®de aux propri√©t√©s et m√©thodes avec l'op√©rateur `->`.

### **1.2 Les m√©thodes et propri√©t√©s statiques**

Les √©l√©ments **statiques** appartiennent √† la classe elle-m√™me, pas aux instances individuelles.

```php
<?php
class Compteur {
    // Propri√©t√© statique
    private static $compteur = 0;
    
    public function __construct() {
        // Incr√©mente le compteur √† chaque nouvelle instance
        self::$compteur++;
    }
    
    // M√©thode statique
    public static function getCompteur() {
        return self::$compteur;
    }
}

// Cr√©ation de plusieurs instances
$obj1 = new Compteur();
$obj2 = new Compteur();
$obj3 = new Compteur();

// Acc√®s √† une m√©thode statique (sans instancier la classe)
echo "Nombre d'instances cr√©√©es : " . Compteur::getCompteur(); // Affiche : 3
?>
```

**Points importants :**
- On utilise `self::` pour acc√©der aux propri√©t√©s/m√©thodes statiques √† l'int√©rieur de la classe.
- On utilise `NomDeLaClasse::` pour y acc√©der depuis l'ext√©rieur.
- Les √©l√©ments statiques sont partag√©s entre toutes les instances.

---

## **üìå 2. Encapsulation et Visibilit√©**  

L'encapsulation est un principe fondamental qui permet de **prot√©ger l'acc√®s** aux propri√©t√©s et m√©thodes d'une classe en utilisant des **modificateurs de visibilit√©**.

### **2.1 Modificateurs d'acc√®s**

PHP propose trois niveaux de visibilit√© :

- **public** : accessible partout, depuis l'int√©rieur ou l'ext√©rieur de la classe.
- **private** : accessible uniquement √† l'int√©rieur de la classe qui les d√©finit.
- **protected** : accessible dans la classe qui les d√©finit et dans les classes qui en h√©ritent.

```php
<?php
class Tache {
    // Propri√©t√©s priv√©es (inaccessibles directement de l'ext√©rieur)
    private $nom;
    private $description;
    private $dateCreation;
    
    public function __construct($nom, $description = '') {
        $this->nom = $nom;
        $this->description = $description;
        $this->dateCreation = date('Y-m-d H:i:s');
    }
    
    // Getters - M√©thodes pour acc√©der aux propri√©t√©s priv√©es
    public function getNom() {
        return $this->nom;
    }
    
    public function getDescription() {
        return $this->description;
    }
    
    public function getDateCreation() {
        return $this->dateCreation;
    }
    
    // Setters - M√©thodes pour modifier les propri√©t√©s priv√©es
    public function setNom($nouveauNom) {
        // Validation possible avant modification
        if (strlen($nouveauNom) > 0) {
            $this->nom = $nouveauNom;
            return true;
        }
        return false;
    }
    
    public function setDescription($nouvelleDescription) {
        $this->description = $nouvelleDescription;
        return true;
    }
}

$tache = new Tache("Apprendre PHP");

// Utilisation correcte via les getters et setters
echo "Nom de la t√¢che : " . $tache->getNom() . "<br>";
$tache->setNom("Ma√Ætriser PHP");
echo "Nouveau nom : " . $tache->getNom() . "<br>";

// Tentative d'acc√®s direct √† une propri√©t√© priv√©e (g√©n√®re une erreur)
// echo $tache->nom; // Fatal error: Cannot access private property
?>
```

### **2.2 Avantages de l'encapsulation**

1. **Contr√¥le de l'acc√®s** : Emp√™che la modification accidentelle ou malveillante des donn√©es.
2. **Validation des donn√©es** : Les setters permettent de v√©rifier la validit√© des donn√©es avant modification.
3. **Abstraction** : Cache les d√©tails d'impl√©mentation et expose uniquement une interface publique.
4. **Flexibilit√©** : Permet de modifier l'impl√©mentation interne sans affecter le code externe.

---

## **üìå 3. H√©ritage et Polymorphisme**  

### **3.1 H√©ritage : Extension des fonctionnalit√©s**

L'h√©ritage permet √† une classe **d'h√©riter** des propri√©t√©s et m√©thodes d'une autre classe, ce qui favorise la r√©utilisation du code.

```php
<?php
// Classe parent (ou classe de base)
class Tache {
    protected $id;
    protected $nom;
    protected $statut;
    
    public function __construct($nom) {
        $this->id = uniqid();
        $this->nom = $nom;
        $this->statut = '√Ä faire';
    }
    
    public function getNom() {
        return $this->nom;
    }
    
    public function getStatut() {
        return $this->statut;
    }
    
    public function terminer() {
        $this->statut = 'Termin√©e';
    }
    
    public function afficherDetails() {
        return "T√¢che [{$this->id}] : {$this->nom} - Statut : {$this->statut}";
    }
}

// Classe enfant (ou classe d√©riv√©e)
class TacheUrgente extends Tache {
    private $priorite;
    private $dateEcheance;
    
    public function __construct($nom, $priorite, $dateEcheance = null) {
        // Appel du constructeur parent
        parent::__construct($nom);
        
        $this->priorite = $priorite;
        $this->dateEcheance = $dateEcheance;
        
        // Personnalisation du statut pour les t√¢ches urgentes
        $this->statut = 'URGENT - √Ä faire';
    }
    
    public function getPriorite() {
        return $this->priorite;
    }
    
    // Red√©finition (override) de la m√©thode du parent
    public function afficherDetails() {
        // On peut utiliser la m√©thode parent comme base
        $details = parent::afficherDetails();
        
        // Puis y ajouter des informations sp√©cifiques
        $details .= " | Priorit√© : {$this->priorite}";
        if ($this->dateEcheance) {
            $details .= " | √âch√©ance : {$this->dateEcheance}";
        }
        
        return $details;
    }
}

// Utilisation des classes
$tache = new Tache("R√©viser PHP");
$tacheUrgente = new TacheUrgente("Corriger le bug critique", "Haute", "2023-12-01");

echo $tache->afficherDetails() . "<br>";
echo $tacheUrgente->afficherDetails() . "<br>";

// La classe enfant h√©rite des m√©thodes du parent
$tacheUrgente->terminer();
echo $tacheUrgente->afficherDetails() . "<br>";
?>
```

### **Points importants sur l'h√©ritage :**

1. Une classe enfant **h√©rite** de toutes les propri√©t√©s et m√©thodes non-priv√©es de la classe parent.
2. Le mot-cl√© `extends` √©tablit la relation d'h√©ritage.
3. `parent::` permet d'acc√©der aux membres de la classe parent.
4. Une classe enfant peut **red√©finir** (override) les m√©thodes du parent.
5. Une classe enfant peut **√©tendre** le parent avec de nouvelles propri√©t√©s et m√©thodes.
6. PHP ne supporte pas l'**h√©ritage multiple** (une classe ne peut h√©riter que d'une seule classe).

### **3.2 Polymorphisme : Flexibilit√© dans l'utilisation**

Le polymorphisme permet de traiter des objets de diff√©rentes classes d√©riv√©es √† travers une interface commune.

```php
<?php
// Fonction qui peut traiter diff√©rents types de t√¢ches
function afficherTache(Tache $tache) {
    echo "Affichage : " . $tache->afficherDetails() . "<br>";
}

// Utilisation avec diff√©rentes classes de t√¢ches
$tacheSimple = new Tache("Faire les courses");
$tacheUrgente = new TacheUrgente("Payer la facture", "Haute");

// M√™me fonction, comportement diff√©rent selon le type d'objet
afficherTache($tacheSimple);
afficherTache($tacheUrgente);
?>
```

**Avantages du polymorphisme :**
- Code plus **g√©n√©rique** et **r√©utilisable**
- **Extensibilit√©** : Ajout de nouveaux types sans modifier le code existant
- **Flexibilit√©** dans l'utilisation des objets

---

## **üìå 4. Classes Abstraites et Interfaces**  

### **4.1 Classes Abstraites : D√©finir une structure commune**

Une **classe abstraite** ne peut pas √™tre instanci√©e directement et peut contenir √† la fois des m√©thodes abstraites (sans impl√©mentation) et des m√©thodes concr√®tes (avec impl√©mentation).

```php
<?php
// Classe abstraite
abstract class ElementTache {
    protected $id;
    protected $dateCreation;
    
    public function __construct() {
        $this->id = uniqid();
        $this->dateCreation = date('Y-m-d H:i:s');
    }
    
    // M√©thode concr√®te (avec impl√©mentation)
    public function getId() {
        return $this->id;
    }
    
    public function getDateCreation() {
        return $this->dateCreation;
    }
    
    // M√©thode abstraite (sans impl√©mentation)
    abstract public function afficher();
}

// Classes concr√®tes qui √©tendent la classe abstraite
class Tache extends ElementTache {
    private $nom;
    
    public function __construct($nom) {
        parent::__construct();
        $this->nom = $nom;
    }
    
    // Impl√©mentation obligatoire de la m√©thode abstraite
    public function afficher() {
        return "T√¢che : {$this->nom} (ID: {$this->id})";
    }
}

class Categorie extends ElementTache {
    private $nom;
    private $couleur;
    
    public function __construct($nom, $couleur = '#CCCCCC') {
        parent::__construct();
        $this->nom = $nom;
        $this->couleur = $couleur;
    }
    
    // Impl√©mentation obligatoire de la m√©thode abstraite
    public function afficher() {
        return "Cat√©gorie : {$this->nom} (Couleur: {$this->couleur})";
    }
}

// Utilisation
// $element = new ElementTache(); // Erreur : impossible d'instancier une classe abstraite
$tache = new Tache("Apprendre les classes abstraites");
$categorie = new Categorie("√âtudes", "#3366FF");

echo $tache->afficher() . "<br>";
echo $categorie->afficher() . "<br>";
?>
```

### **4.2 Interfaces : D√©finir des contrats**

Une **interface** d√©finit uniquement la signature des m√©thodes, sans aucune impl√©mentation. Une classe peut impl√©menter plusieurs interfaces.

```php
<?php
// D√©finition d'interfaces
interface Affichable {
    public function afficher();
}

interface Exportable {
    public function exporterHTML();
    public function exporterJSON();
}

// Classe impl√©mentant plusieurs interfaces
class Tache implements Affichable, Exportable {
    private $nom;
    private $description;
    
    public function __construct($nom, $description = '') {
        $this->nom = $nom;
        $this->description = $description;
    }
    
    // Impl√©mentation des m√©thodes de l'interface Affichable
    public function afficher() {
        return "T√¢che : {$this->nom}";
    }
    
    // Impl√©mentation des m√©thodes de l'interface Exportable
    public function exporterHTML() {
        return "<div class='tache'><h3>{$this->nom}</h3><p>{$this->description}</p></div>";
    }
    
    public function exporterJSON() {
        return json_encode([
            'nom' => $this->nom,
            'description' => $this->description
        ]);
    }
}

// Utilisation
$tache = new Tache("Apprendre les interfaces", "Comprendre leur utilit√© et mise en ≈ìuvre");

echo $tache->afficher() . "<br>";
echo $tache->exporterHTML() . "<br>";
echo $tache->exporterJSON() . "<br>";
?>
```

### **Diff√©rences entre Classes Abstraites et Interfaces :**

| Caract√©ristique | Classe Abstraite | Interface |
|-----------------|------------------|-----------|
| Instanciation   | Impossible       | Impossible |
| M√©thodes        | Abstraites et concr√®tes | Uniquement abstraites |
| Propri√©t√©s      | Peut avoir des propri√©t√©s | Uniquement constantes |
| H√©ritage        | Une seule classe | Plusieurs interfaces |
| But principal   | Partager du code commun | D√©finir un contrat |

---

## **üìå 5. Traits : R√©utiliser du code horizontalement**

Les **traits** permettent de r√©utiliser des m√©thodes dans plusieurs classes ind√©pendantes, r√©solvant partiellement les limitations de l'h√©ritage simple en PHP.

```php
<?php
// D√©finition d'un trait
trait Horodatable {
    private $dateCreation;
    private $dateMiseAJour;
    
    public function initialiserDates() {
        $this->dateCreation = date('Y-m-d H:i:s');
        $this->dateMiseAJour = $this->dateCreation;
    }
    
    public function mettreAJour() {
        $this->dateMiseAJour = date('Y-m-d H:i:s');
    }
    
    public function getDateCreation() {
        return $this->dateCreation;
    }
    
    public function getDateMiseAJour() {
        return $this->dateMiseAJour;
    }
}

trait Journalisable {
    public function journaliser($message) {
        $date = date('Y-m-d H:i:s');
        $classe = get_class($this);
        echo "[$date] [$classe] $message<br>";
    }
}

// Utilisation des traits dans des classes
class Tache {
    // Inclusion des traits
    use Horodatable, Journalisable;
    
    private $nom;
    
    public function __construct($nom) {
        $this->nom = $nom;
        $this->initialiserDates();
        $this->journaliser("T√¢che cr√©√©e : {$this->nom}");
    }
    
    public function setNom($nouveauNom) {
        $this->nom = $nouveauNom;
        $this->mettreAJour();
        $this->journaliser("Nom modifi√© : {$this->nom}");
    }
}

class Utilisateur {
    // R√©utilisation des m√™mes traits
    use Horodatable, Journalisable;
    
    private $nom;
    private $email;
    
    public function __construct($nom, $email) {
        $this->nom = $nom;
        $this->email = $email;
        $this->initialiserDates();
        $this->journaliser("Utilisateur cr√©√© : {$this->nom}");
    }
}

// Utilisation des classes avec traits
$tache = new Tache("Comprendre les traits");
echo "T√¢che cr√©√©e le : " . $tache->getDateCreation() . "<br>";

$tache->setNom("Ma√Ætriser les traits en PHP");
echo "T√¢che mise √† jour le : " . $tache->getDateMiseAJour() . "<br>";

$utilisateur = new Utilisateur("Jean Dupont", "jean@example.com");
?>
```

**Avantages des traits :**
- **R√©utilisation de code** entre classes qui n'ont pas de relation d'h√©ritage
- **Composition de fonctionnalit√©s** pour √©viter les limitations de l'h√©ritage simple
- **Organisation du code** en composants r√©utilisables

---

## **üìå 6. M√©thodes Magiques en PHP**

PHP propose des **m√©thodes magiques** qui sont appel√©es automatiquement lors d'√©v√©nements sp√©cifiques.

```php
<?php
class Tache {
    private $proprietes = [];
    
    // Appel√© lors de l'instanciation
    public function __construct($nom = '') {
        $this->proprietes['nom'] = $nom;
        $this->proprietes['date_creation'] = date('Y-m-d H:i:s');
    }
    
    // Appel√© lors de l'acc√®s √† une propri√©t√© inaccessible/inexistante
    public function __get($nom) {
        if (array_key_exists($nom, $this->proprietes)) {
            return $this->proprietes[$nom];
        }
        return null;
    }
    
    // Appel√© lors de la modification d'une propri√©t√© inaccessible/inexistante
    public function __set($nom, $valeur) {
        $this->proprietes[$nom] = $valeur;
        $this->proprietes['date_modification'] = date('Y-m-d H:i:s');
    }
    
    // Appel√© lors de l'utilisation de isset() ou empty() sur une propri√©t√©
    public function __isset($nom) {
        return isset($this->proprietes[$nom]);
    }
    
    // Appel√© lors de l'utilisation de unset() sur une propri√©t√©
    public function __unset($nom) {
        unset($this->proprietes[$nom]);
    }
    
    // Appel√© lors de la conversion de l'objet en cha√Æne
    public function __toString() {
        return "T√¢che : {$this->proprietes['nom']}";
    }
    
    // Appel√© lors de la s√©rialisation
    public function __sleep() {
        return ['proprietes'];
    }
    
    // Appel√© lors de la d√©s√©rialisation
    public function __wakeup() {
        if (!isset($this->proprietes['date_reveil'])) {
            $this->proprietes['date_reveil'] = date('Y-m-d H:i:s');
        }
    }
}

$tache = new Tache("Apprendre les m√©thodes magiques");

// Utilisation de __get et __set
echo $tache->nom . "<br>"; // __get
$tache->priorite = "Haute"; // __set
echo $tache->priorite . "<br>"; // __get

// Utilisation de __toString
echo $tache . "<br>"; // __toString

// Utilisation de __isset et __unset
echo (isset($tache->priorite) ? "La priorit√© est d√©finie" : "La priorit√© n'est pas d√©finie") . "<br>"; // __isset
unset($tache->priorite); // __unset
echo (isset($tache->priorite) ? "La priorit√© est d√©finie" : "La priorit√© n'est pas d√©finie") . "<br>"; // __isset

// Utilisation de __sleep et __wakeup
$serialized = serialize($tache); // __sleep
$unserialized = unserialize($serialized); // __wakeup
echo "Date de r√©veil : " . $unserialized->date_reveil . "<br>";
?>
```

**Liste des principales m√©thodes magiques :**
- `__construct()` : Constructeur
- `__destruct()` : Destructeur
- `__get()` : Acc√®s √† une propri√©t√© inaccessible
- `__set()` : Modification d'une propri√©t√© inaccessible
- `__isset()` : V√©rification d'une propri√©t√© avec isset()
- `__unset()` : Suppression d'une propri√©t√© avec unset()
- `__toString()` : Conversion de l'objet en cha√Æne
- `__invoke()` : Appel de l'objet comme une fonction
- `__clone()` : Clonage de l'objet
- `__sleep()` : Pr√©paration √† la s√©rialisation
- `__wakeup()` : Restauration apr√®s d√©s√©rialisation
- `__call()` : Appel d'une m√©thode inaccessible
- `__callStatic()` : Appel d'une m√©thode statique inaccessible

---

Bien s√ªr ! Reprenons le cours l√† o√π nous nous √©tions arr√™t√©s.

---

## **üìå 7. Mini-Projet : Gestionnaire de T√¢ches en POO (suite)**  

### **7.1 Impl√©mentation des Utilisateurs**

Dans un syst√®me de gestion de t√¢ches, il est essentiel d'avoir des utilisateurs qui peuvent cr√©er et g√©rer leurs propres t√¢ches. Nous allons donc ajouter une classe `Utilisateur` pour repr√©senter ces utilisateurs.

```php
<?php

class Utilisateur extends ElementGestionnaire {
    private $email;
    private $taches = [];
    
    public function __construct($nom, $email) {
        parent::__construct($nom);
        $this->email = $email;
    }
    
    public function getEmail() {
        return $this->email;
    }
    
    public function setEmail($email) {
        $this->email = $email;
        $this->mettreAJour();
    }
    
    public function ajouterTache(Tache $tache) {
        $this->taches[$tache->getId()] = $tache;
    }
    
    public function getTaches() {
        return $this->taches;
    }
    
    public function afficher() {
        $result = "Utilisateur: {$this->nom} | Email: {$this->email} ";
        $result .= "T√¢ches associ√©es: " . count($this->taches) . " ";
        
        foreach ($this->taches as $tache) {
            $result .= " - " . $tache->afficher() . " ";
        }
        
        return $result;
    }
}

// Exemple d'utilisation
$categorie = new Categorie("Travail", "#FF5733");
$tache1 = new Tache("R√©union avec l'√©quipe", "Discuter du projet X", $categorie);
$tache2 = new Tache("Pr√©paration du rapport", "R√©diger le rapport mensuel", $categorie);

$utilisateur = new Utilisateur("Alice Dupont", "alice@example.com");
$utilisateur->ajouterTache($tache1);
$utilisateur->ajouterTache($tache2);

echo $utilisateur->afficher();
?>
```

**Explication :**
1. La classe `Utilisateur` h√©rite de la classe abstraite `ElementGestionnaire` et utilise le trait `Horodatable`.
2. Chaque utilisateur a un email et une liste de t√¢ches qu'il peut g√©rer.
3. Les m√©thodes `ajouterTache()` et `getTaches()` permettent de manipuler les t√¢ches associ√©es √† un utilisateur.
4. La m√©thode `afficher()` fournit une vue d√©taill√©e des informations de l'utilisateur et de ses t√¢ches.

---

### **7.2 Exportation des Donn√©es**

Pour rendre notre gestionnaire de t√¢ches plus flexible, nous allons impl√©menter des fonctionnalit√©s d'exportation des donn√©es au format HTML et JSON.

```php
<?php

interface Exportable {
    public function exporterHTML();
    public function exporterJSON();
}

// Classe Tache (mise √† jour)
class Tache extends ElementGestionnaire implements Exportable {
    // ... Code pr√©c√©dent ...
    
    public function exporterHTML() {
        $html = "<div>";
        $html .= "<h3>{$this->nom}</h3>";
        
        if (!empty($this->description)) {
            $html .= "<p><strong>Description :</strong> {$this->description}</p>";
        }
        
        $html .= "<p><strong>Statut :</strong> {$this->statut}</p>";
        
        if ($this->categorie) {
            $html .= "<p><strong>Cat√©gorie :</strong> {$this->categorie->getNom()}</p>";
        }
        
        $html .= "<p><strong>Cr√©√©e le :</strong> {$this->getDateCreation()}</p>";
        $html .= "</div>";
        
        return $html;
    }
    
    public function exporterJSON() {
        $data = [
            'id' => $this->id,
            'nom' => $this->nom,
            'description' => $this->description,
            'statut' => $this->statut,
            'date_creation' => $this->getDateCreation(),
            'date_mise_a_jour' => $this->getDateMiseAJour()
        ];
        
        if ($this->categorie) {
            $data['categorie'] = $this->categorie->getNom();
        }
        
        return json_encode($data, JSON_PRETTY_PRINT);
    }
}

// Exemple d'utilisation
$tache = new Tache("Apprendre PHP", "Ma√Ætriser les bases de la POO");
echo $tache->exporterHTML();
echo $tache->exporterJSON();
?>
```

**Avantages de l'exportation :**
- **HTML** : Permet d'afficher les donn√©es dans une interface web.
- **JSON** : Facilite l'√©change de donn√©es avec des API ou d'autres syst√®mes.

---

### **7.3 Ajout de Fonctionnalit√©s Avanc√©es**

Nous pouvons am√©liorer notre gestionnaire de t√¢ches en ajoutant des fonctionnalit√©s suppl√©mentaires :
1. **Priorit√© des t√¢ches** : Ajouter un attribut `priorite` √† la classe `Tache`.
2. **√âch√©ances** : Ajouter une propri√©t√© `dateEcheance` pour suivre les d√©lais.
3. **Notifications** : Impl√©menter un syst√®me de rappels pour les t√¢ches proches de leur √©ch√©ance.
4. **Filtrage et Tri** : Ajouter des m√©thodes pour filtrer et trier les t√¢ches par statut, priorit√©, etc.

Voici un exemple d'impl√©mentation pour la priorit√© :

```php
<?php

class Tache extends ElementGestionnaire implements Exportable {
    private $priorite;
    
    public function __construct($nom, $description = '', $priorite = 'Normale', Categorie $categorie = null) {
        parent::__construct($nom);
        $this->description = $description;
        $this->statut = '√Ä faire';
        $this->priorite = $priorite;
        
        if ($categorie) {
            $this->categorie = $categorie;
            $categorie->ajouterTache($this);
        }
    }
    
    public function getPriorite() {
        return $this->priorite;
    }
    
    public function setPriorite($priorite) {
        $this->priorite = $priorite;
        $this->mettreAJour();
    }
    
    public function afficher() {
        $result = "T√¢che: {$this->nom} | Priorit√©: {$this->priorite} | Statut: {$this->statut}";
        
        if (!empty($this->description)) {
            $result .= " | Description: {$this->description}";
        }
        
        if ($this->categorie) {
            $result .= " | Cat√©gorie: {$this->categorie->getNom()}";
        }
        
        return $result;
    }
}

// Exemple d'utilisation
$tache = new Tache("Finaliser le projet", "Terminer toutes les fonctionnalit√©s", "Haute");
echo $tache->afficher();
?>
```

---

## **üìå 8. Bonnes Pratiques en POO**

### **8.1 Single Responsibility Principle (SRP)**  
Chaque classe doit avoir une seule responsabilit√©. Par exemple, une classe `Tache` ne devrait pas g√©rer les utilisateurs ou les cat√©gories directement.

### **8.2 Open/Closed Principle (OCP)**  
Les classes doivent √™tre ouvertes √† l'extension mais ferm√©es √† la modification. Utilisez des interfaces et des classes abstraites pour faciliter l'extensibilit√©.

### **8.3 DRY (Don't Repeat Yourself)**  
√âvitez la duplication de code en utilisant des traits, des classes abstraites et des m√©thodes r√©utilisables.

### **8.4 KISS (Keep It Simple, Stupid)**  
Concevez votre code de mani√®re simple et compr√©hensible. √âvitez les complexit√©s inutiles.

### **8.5 Documentation et Commentaires**  
Documentez vos classes, m√©thodes et propri√©t√©s pour faciliter la maintenance et la collaboration.

---

## **üéØ Conclusion**

La **Programmation Orient√©e Objet (POO)** est un paradigme puissant qui vous permet de structurer et modulariser votre code de mani√®re efficace. En comprenant et appliquant les concepts de base (classes, objets, encapsulation, h√©ritage, polymorphisme) ainsi que les concepts avanc√©s (interfaces, traits, m√©thodes magiques), vous pouvez cr√©er des applications robustes, maintenables et √©volutives.

Avec ce mini-projet de gestionnaire de t√¢ches, vous avez maintenant une base solide pour d√©velopper des projets plus complexes en PHP. Continuez √† pratiquer et √† explorer les possibilit√©s offertes par la POO !

---

Si vous avez des questions ou si vous souhaitez approfondir un sujet sp√©cifique, n'h√©sitez pas √† demander ! üòä